[TOC]
图挖掘
===
频繁子图挖掘
---

> 在图集中找到 **频繁出现的** 子集模式--用 **支持度** 度量
> **即从候选集中找到频繁子图集** 

##基本概念
- **支持度**: 与给定的图 G **子图同构的图** 的数量占图数据库D中图总量的百分比
- **候选集**: 待处理的子图集
- **频繁子图集(频繁项集,最大项目集)**: 支持度大于最小支持度的项集(满足条件的项)

## 常用算法
> 关键是对 **扩展边** 的算法的改进.

### Apriori 算法
1. **解决问题**:
	从事务数据库挖掘 **布尔关联规则** ,即一起出现的
2. **核心思想**: 
	1. **基于两阶段频集思想的逆推算法** 
	2. 单维,单层,布尔关联规则.
	3. **基于归纳循环的**
3. **具体步骤**:
	1. 简单统计所有含一个元素项目集出现的 **频数**，并找出那些不小于最小支持度的项目集，即*** 一维最大项目集*** 。
	2. 从第二步开始循环处理直到再没有最大项目集生成。
	3. 循环过程是：
		1. 第k步中，**根据第k-1步生成的(k-1)维最大项目集扩展产生k维侯选项目集:如何生成**?，
		2. 然后对数据库进行搜索，得到侯选项目集的项集支持度，与最小支持度进行比较，从而找到k维最大项目集。
4. **备注**:
	由k-1维到k维的扩展: **有不同的扩展方法**.
	如Apriori,判断 **项目集中元素的所有组合** 是否出现在D中
5. **存在问题**:

> 1. 找到1到k维的最大项目集,低效.
> 2. 仅仅用元素项目项目集出现的频数来算支持度,忽略了图的联系;
> 3. 由于存在子图同构的问题，在生成候选子图时容易产生很多冗余子图

###AGM 算法 -- 基于Apriori
1. 将图用邻接矩阵表示, **按照顶点的标签** 来排序顶点在邻接矩阵中的顺序. **顶点增长**
2. 为每个邻接矩阵建立图的编码标记形式
3. **频繁诱导子图** 的候选集依据子图的大小分层搜索得到.

###FP-growth算法 
进行两次扫描,不使用候选集

###FSG -- 对Apriori的改进
1. **解决问题**
	Apriori算法从k阶子图扩展到k+1阶时太多冗余,AGM的一种改进. 采用了 **分级扩展** 的方法

2. **核心思想**
	1. 采用 **稀疏** 的图的表示方法
	2. 算法FSG在产生k+l候选子图时，**每次添加一条边** 来扩展频繁子图 (通过 **连接(JOIN)两个拥有相同k—l子图的k子图** 来实现)。
	> 由于1. 顶点同标签; 2. core的多态; 3.多个核
	3. 在判断两个k子图是否有相同的k-1子图时采用 **每次删除一条边** 的方法，同构是NP问题
	4. 采用对小图更加有效地 **规范标签和图同构算法** .
	5. 优化生成候选集,使之能适用于大规模的图数据库.

3. **关键步骤**
	1. 标示 **核心** : 判断是否有同样的core: 同构
	2. join.连接两个图:并,加入到 **可能的候选集(临时T)中**
	3. 得到并集(可能的候选集)之后,检查里面的每个图, **判断是否在候选集C中了** :去除冗余
		1. 如果不在,利用支持度计算的 **downward clousre性质减少候选** ,验证 **是否所有k-1阶子图都是频繁的** :比较次数的期望减少 . 若是,则加入候选集

4. **伪代码**
	1. 主函数--AGM思想![](http://i.imgur.com/wa8Vdu7.jpg)<br>
		F:频繁子图,g:k阶子图
	2. *** 候选集生成函数*** ![](http://i.imgur.com/sqd7aLU.jpg)
		用transaction ID list来对每个频繁子图维护一个事务标示符的列表, 当计算k+1阶子图的频繁度时,先计算其k阶子图的TID列表的交叉两: 
		若低于阈值,则舍弃;否则计算和搜索也仅限于TID列表的交叉事务集中. 
		cl: canonical labels
		
5. **存在问题**
	1. 仍产生了冗余的候选模式子图,需要进行规范化判断.
	2. 不适合大规模的图: **给出基于MapReduce的FGS实现**

###FFSM
 
###Spin

###gSpan
gSpan--graph-based Substructure pattern mining 
1. 对图进行**深度优先** 搜索发现频繁子图.
2. 按照便利顺序标注下表. v0为根,vn最右顶点

###CloseGraph

###MapReduce-FSG