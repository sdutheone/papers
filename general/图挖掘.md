[TOC]
图挖掘
===
频繁子图挖掘
---

> 在图集中找到 __频繁出现的__ 子集模式--用 __支持度__ 度量
> __即从候选集中找到频繁子图集__ 


##基本概念
- __支持度__: 与给定的图 G __子图同构的图__ 的数量占图数据库D中图总量的百分比
- __候选集__: 待处理的子图集
- __频繁子图集(频繁项集,最大项目集)__: 支持度大于最小支持度的项集(满足条件的项)

## 常用算法
> 关键是对 __扩展边__ 的算法的改进.

### Apriori 算法
1. __解决问题__:
	从事务数据库挖掘 __布尔关联规则__ ,即一起出现的
2. __核心思想__: 
	1. __基于两阶段频集思想的逆推算法__ 
	2. 单维,单层,布尔关联规则.
	3. __基于归纳循环的__
3. __具体步骤__:
	1. 简单统计所有含一个元素项目集出现的 __频数__，并找出那些不小于最小支持度的项目集，即___ 一维最大项目集___ 。
	2. 从第二步开始循环处理直到再没有最大项目集生成。
	3. 循环过程是：
		1. 第k步中，__根据第k-1步生成的(k-1)维最大项目集扩展产生k维侯选项目集:如何生成__?，
		2. 然后对数据库进行搜索，得到侯选项目集的项集支持度，与最小支持度进行比较，从而找到k维最大项目集。
4. __备注__:
	由k-1维到k维的扩展: __有不同的扩展方法__.
	如Apriori,判断 __项目集中元素的所有组合__ 是否出现在D中
6. __存在问题__:

> 1. 找到1到k维的最大项目集,低效.
> 2. 仅仅用元素项目项目集出现的频数来算支持度,忽略了图的联系;
> 3. 由于存在子图同构的问题，在生成候选子图时容易产生很多冗余子图

###AGM 算法 -- 基于Apriori
1. 将图用邻接矩阵表示, __按照顶点的标签__ 来排序顶点在邻接矩阵中的顺序. __顶点增长__
2. 为每个邻接矩阵建立图的编码标记形式
3. __频繁诱导子图__ 的候选集依据子图的大小分层搜索得到.

###FP-growth算法 
进行两次扫描,不使用候选集

###FSG -- 对Apriori的改进
1. __解决问题__
	Apriori算法从k阶子图扩展到k+1阶时太多冗余,AGM的一种改进. 采用了 __分级扩展__ 的方法
2. __核心思想__
	1. 采用 __稀疏__ 的图的表示方法
	2. 算法FSG在产生k+l候选子图时，__每次添加一条边__ 来扩展频繁子图 (通过 __连接(JOIN)两个拥有相同k—l子图的k子图__ 来实现)。
	> 由于1. 顶点同标签; 2. core的多态; 3.多个核
	3. 在判断两个k子图是否有相同的k-1子图时采用 __每次删除一条边__ 的方法，同构是NP问题
	4. 采用对小图更加有效地 __规范标签和图同构算法__ .
	5. 优化生成候选集,使之能适用于大规模的图数据库.

3. __关键步骤__
	1. 标示 __核心__ : 判断是否有同样的core: 同构
	2. join.连接两个图:并,加入到 __可能的候选集(临时T)中__
	3. 得到并集(可能的候选集)之后,检查里面的每个图, __判断是否在候选集C中了__ :去除冗余
		1. 如果不在,利用支持度计算的 __downward clousre性质减少候选__ ,验证 __是否所有k-1阶子图都是频繁的__ :比较次数的期望减少 . 若是,则加入候选集

4. __伪代码__
	1. 主函数--AGM思想![](http://i.imgur.com/wa8Vdu7.jpg)<br>
		F:频繁子图,g:k阶子图
	2. ___ 候选集生成函数___ ![](http://i.imgur.com/sqd7aLU.jpg)
		用transaction ID list来对每个频繁子图维护一个事务标示符的列表, 当计算k+1阶子图的频繁度时,先计算其k阶子图的TID列表的交叉两: 
		若低于阈值,则舍弃;否则计算和搜索也仅限于TID列表的交叉事务集中. 
		cl: canonical labels
5. __存在问题__
	1. 仍产生了冗余的候选模式子图,需要进行规范化判断.
	2. 不适合大规模的图: __给出基于MapReduce的FGS实现__


###FFSM
 
###Spin

###gSpan
gSpan--graph-based Substructure pattern mining 
1. 对图进行__深度优先__ 搜索发现频繁子图.
2. 按照便利顺序标注下表. v0为根,vn最右顶点

###CloseGraph

###MapReduce-FSG