29-基于map-reduce的高效,频繁子图,挖掘算法
===
###解决问题
> 修正了MapReduce-FSG算法存在的问题,进一步提高了运行效率
> 如: MapReduce-FSG 含有多个相同的边,或者多个相同的结点标示字母时不能正确处理

###核心思想:
1. 在扩展边生成新的子图时，使用已经**挖掘出的支持度为 k-1 的频繁子图**生成**频繁度为 k 的频繁子图**。
2. 同时，检查是否存在待扩展生成的子图. 
3. **定义边的格式**,五元组(起点的标号|终点的标号|边上的信息|起点的信息|终点的信息)

### 主要步骤
- **流程图**
![](http://i.imgur.com/sbrxaFc.jpg)

- **流程图解释**
1. ParserMapper:相当于**初始化用户输入**. **输出**为(key=边所有信息,value=其他信息)
2. MapperB:**按照边来划分**. **输出为**(key=边信息(格式化),value=标识+图ID))
3. ReducerB:按相同的边,**计算support**,**输出为**(key=指定格式的边,value=空)
4. MapperA: **按照图ID划分**. **输出为**(key=边信息(按图ID划分),value=空)
5. ReducerA: **扩展一条边,从k-1维扩展到k维**: **输出为**(key=指定格式的所有边信息,value=空)
6. MapperB...循环

>MapperB/ReducerB: 子图的分类
>MapperA/ReducerA: 扩展边

### 创新点
**ReducerA**:基于边的候选产生--去除重复性

**加入潜在的候选边,用字符串排序避免重复**
1. 将ReducerB挖掘出的图解析成单独的边集合(映射关系),放入临时集合A
2. 对于一条待扩展的边,**加入A**,并判断A的字符串是否在B的字符串中(**避免产生复制图--相同的图**)
	- 两个集合A,B. B对应**当前最大频繁子图**,A是临时集合

**算法通用性?**

- **用排序保证算法的通用性**
- 先**部分排序**:终点按照字母表排序
- 后**整体排序**:起点排序
